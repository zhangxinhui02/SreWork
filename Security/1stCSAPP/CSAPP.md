# 课前预习:
- 提前了解[汇编](https://blog.csdn.net/qq_39654127/article/details/88698911)
- 第一章
- 第二章
- 第三章
- 第七章
- 第九章
- 只要求大概看一眼,有个概念

# 介绍
CSAPP全名Computer system a programer's perspective.英文直译:从程序员的视角看待计算机系统.这本书可谓是经典了，<<漏洞战争>>一书中,作者这样写道:
![在这里插入图片描述](https://img-blog.csdnimg.cn/37f46960805948919a9c76b2c2234af4.png#pic_center)
看了这本书之后，计算机对你,就不在是一个黑盒 [^黑盒]   

[^黑盒]:  [黑盒测试](https://baike.baidu.com/item/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/10617194?fr=aladdin)

# 部分内容

- 编译驱动程序
- 目标文件结构
- 汇编语言
- 加载文件的加载
- 汇编语言&栈
- 堆
#  编译驱动程序
![在这里插入图片描述](https://img-blog.csdnimg.cn/d4689d03548b49abbfdd30d0f454c87f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTk1MzEz,size_16,color_FFFFFF,t_70#pic_center)

当我们在运行g++ main.cpp 时,其编译过程,并不是一步到位的,而且g++ 并不是编译器的全部,而只是一个编译驱动器,它调用了好几个处理程序,来处理我们写的代码,最终生成一个可执行文件.

## 预处理
预编译过程主要处理那些源代码文件中以 "#"开始的预编译指令。比如"#include"、"#define"等，主要处理规则如下：

- 将所有的 "#define" 删除，并且展开所有的宏定义
- 处理"#include"预编译指令，将被包含的文件插入到该预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件
- 删除所有的注释

## 编译与优化
- 经过预编译得到的输出文件中，只有常量；如数字、字符串、变量的定义，以及C语言的关键字，如main, if , else , for , while , { , } , + , - , * , \ 等等。
- 编译程序所要作得工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码或汇编代码。
- 然后就是对代码进行优化处理. 优化处理是编译系统中一项比较艰深的技术。它涉及到的问题不仅同编译技术本身有关，而且同机器的硬件环境也有很大的关系,这里也就不过于展开的讲了.

## 汇编
汇编就是把汇编语言代码翻译成目标***机器指令***的过程。被编译驱动器处理的每一个C语言源程序，都将最终经过这一处理而得到相应的目标文件。目标文件中所存放的就是与源程序实现功能等效的目标的机器语言代码。
现在生成的文件,已经有可执行文件结构的雏形了,再经过链接,它就是一个成熟的二进制文件了

## 静态链接

编译过程的最后,也是最重要的,就是静态链接,静态链接器执行以下操作:

- 组合目标文件: 例如写了好几个c语言的源码,一个包含主函数,而其他几个写的是实现其他功能的函数,在链接的时候,就会把这几个源码生产的目标文件组合起来,就算是只这了一份源码,链接器也会自动的链接一些启动函数进去
	- 符号解析
		- 什么是符号: 每个符号对应了一个函数,全局变量或者一个静态变量
		- 解析了什么:把每个符号的引用与一个符号的定义关联起来, 例如一个源文件中可能引用了另一个源文件中的某个函数,全局变量,也就是符号.例如在第一个文件中调用了第二个文件中的一个变量,但是在没有进行符号解析之前,它也不知道它调用了啥, 需要符号解析告诉它,你调用的是第二个文件中的某某某个变量
- 静态重定位: 
	- 重定位节和符号定义: 在这一步中,链接器将所有相同类型的数据合成一个节,比如将所有的代码节合成一个到一个代码节
	- 重定位节中的符号引用: 重定位的时候, 链接器通过把每个符号的定义,与内存位置关联起来,把符号的定义和内存位置关联过后,再修改那些符号的引用,让他们指向那个内存位置,也就是确定每个符号在运行时的内存位置
	- 深入~~~

## 与静态库链接
如果我们在编译时加上-static参数, 那么函数就会在编译的时候把我们需要的调用的linux自带静态库的代码整合成为完全链接的可执行目标文件.
	链接器链接库代码到程序的过程:

 - 把用到的代码合并到程序的.text段中
 - 把调用函数的符号解析到调用它的地方
 - 静态重定位该函数,把函数的地址解析到调用它的地方

# 目标文件结构
程序编译好了,既然要然计算机对我们来说不再是一个黑盒, 那么我们就得理解计算机每一步的操作以及每一步操作对后续产生的影响, 现在我们生成了可执行文件, 但是先不着急运行, 先来看一下编译出来的文件里面,都有些什么东西. 
## 各个平台的目标文件结构
linux,windows,MacOS的软件,不能直接在其他平台上运行,从表面上看,就是因为他们采用了不同的目标文件结构
- windows的可执行文件结构称为pe(Portable Excutab)文件
- Linux为ELF(Excutable and Likable File)
- OS-X使用的是Mach-O格式
这里我们着重讲ELF文件结构,但是很多格式,他们的基本实现原理都是相似的

## ELF文件结构
### ELF header
ELFheader :ELF文件头包含了整个文件的基本属性
- ELF文件版本
- 目标机器的型号
- 程序的入口点地址
- ……
### 链接视图
链接视图就是编译器在进行编译链接时,链接把相同的数据类型组合到一起就形成了一个section节,然后最下面还有一个节头部表,这个节头部表不止一个,而是有很多个, 他们就像是一个又一个的c语言结构体一样的东西,每一个结构体,都包含着与之对应的一个节的基本信息
####  节头部表:
	1. 节名称
	2. 节类型
	3. 节读写权限
	4. 节在ELF文件中所占长度
	5. ……

#### 每个section的含义
	1. text: 已编译程序的机器代码
	2. rodata:只读数据,例如字符串常量
	3. data: 已经初始化的全局和静态c变量
	4. bss: 位初始化的全局和静态c变量,以及所有被初始化位0的全局或静态变量
	5. symtab: 以一个符号表,他存放着程序中定义和引用的函数和全局变量信息
	6. rel.text: 这个sction是和编译的时候的重定位有关的,就是这个节,告诉链接器,机器代码段中,哪个地方的调用需要重定位
	7. rel.data: 同上,也是和重定位有关,就像他的名字一样,它保存的是全局变量,或者一个外部变量的引用,使用到全局变量或者外部变量的地方,也都需要被重定位,解析为地址.
	8. debug: 调试符号表,它的条目是局部变量和符号的定义,就像函数名和变量名,还有c源代码,之前说了,编译的时候,加上-g命令,就会在可执行目标文件中加入这种表
	9. ……
### 执行视图
#### program header
由于程序运行时会被加载到内存中, 有了Program header table中包含的信息,程序的加载器就知道该把ELF文件中的每个section的数据,映射到虚拟内存中的哪个位置了.segment也是通过program header来映射的

#### segment
现在,我们又要逐渐把重点转移到程序的运行时态了, segments是从运行的角度来描述elf文件，sections是从链接的角度来描述elf文件，也就是说，在链接阶段，我们可以忽略program header table来处理此文件，在运行阶段可以忽略section header table来处理此程序。从图中我们也可以看出，segments与sections是包含的关系，一个segment包含若干个section。
> 当ELF文件被加载到内存中后，系统会将多个具有相同权限（flag值）section合并一个segment。操作系统往往以页为基本单位来管理内存分配，一般页的大小为4096B，即4KB的大小。同时，内存的权限管理的粒度也是以页为单位，每个页内的内存是具有同样的权限等属性，并且操作系统对内存的管理往往追求高效和高利用率这样的目标。ELF文件在被映射时，是以系统的页长度为单位的，那么每个section在映射时的长度都是系统页长度的整数倍，如果section的长度不是其整数倍，则导致多余部分也将占用一个页。而我们从上面的例子中知道，一个ELF文件具有很多的section，那么会导致内存浪费严重。如果将多个权限相同的section,比如.data和.symtab组合为成segment,分配到内存中,这样可以减少页面内部的碎片，节省了空间，显著提高内存利用率。
# 加载可执行文件
我们在linux上运行我们自己的程序时, 输入./compile,因为我们自己的程序不是不是shell的内置命令,所以 shell 会认为 prog 是一个可执行目标文 件，通过调用某个驻留在存储器中称为加载器（loader)的操作系统代码来运行它。任何 Linux 程序都可以通过调用 execve 函数来调用加载器. 加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个将程序复制到内存并运行的过程叫做加载。
## 程序的内存映射
每个 Linux 程序都有一个运行时内存映像，如图所示。在 Linux x86 -64系统中，代码段总是从地址 0x400000 处开始，后面是数据段。运行时堆在数据段之后， 通过调用 malloc 库往上增长。堆后面的区域 是为共享模块保留的。用户栈总是从最大的合法用户地址（2e48 -1)开始，向较小内存地址 增长。栈上的区域，从地址 2e48开始，是为内核（kernel)中的代码和数据保留的，所谓内核 就是操作系统驻留在内存的部分。 为了简洁，我们把堆、数据和代码段画得彼此相邻，并且把栈顶放在了最大的合法用户地址处。实际上，由于.data 段有对齐要求，所以代码段和数据段之间是有 间隙的。同时，在分配栈、共享库和堆段运行时地址的时候，链接器还会使用地址空间布局随机化（ASLR）。虽然每次程序运行时这些区域的地址都会改变，它们的相对位置是不变的。也就是同一个区域中所存在的两个数据,他们之间的偏移总是保持一致的

## 动态链接共享库
 windows中的动态链接库后缀是DLL(dynamic link library), linux中是.so(shared object) ,可以看到,linux 的是shared object: 共享目标, linux这个, 它不仅实现了动态链接的功能, 它甚至能被所有程序加载.
> 几乎每个 C 程序都使用标准 I/O 函数，比如 printf 和 scanf。在运行时，这些函数的代码会被复制到每个运行进程的文本段中。在一个运行上百个进程的典型 系统上，这将是对稀缺的内存系统资源的极大浪费。而动态链接很好的解决了这个问题, 所有引用该库的可执行目标文件共享这个. so 文件中的代码和数据，而不是像静态 库的内容那样被复制和嵌入到引用它们的可执行的文件中。在内存中,一个.text节的一个副本可以在被不同的正在运行的进程共享.

可以看到动态链接和静态链接, 在编译的链接过程中,的区别就是动态链接, 只是加入了外部符号表的信息和重定位的信息. 然后在程序加载后, 需要一个ld-linux.so, 也就是动态链接器把代码和数据都链接到我们自己的程序. 而这个链接器也是一个shared object, 也就意味着这个动态链接器的代码也是在内存中,代码段的副本能够被运行的进程共享.

# 汇编语言&栈
## 汇编语言介绍

汇编语言（Assembly Language）是任何一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。特定的汇编语言和特定的机器语言指令集是一一对应的，不同平台之间不可直接移植。

## 指令执行
### 常用寄存器:
x86
- esp: 当前栈帧的栈顶寄存器,保存栈顶的值
- ebp: 当前栈帧的栈底寄存器, 一个函数调用完后, 会利用这个ebp来让栈帧回到调用函数的栈帧
- eax: 函数返回值保存到这个寄存器
- eip: instruction pointer程序计数器, 保存下一条要执行的指令
x86-64:
- rsp: 栈顶指针
- rbp:同上
- rax: 同上
- rdi: 函数传入的第一个参数
- rsi: 第二个参数
- rdx: 第三个参数
- rip:同上
- 除了这几个特殊的寄存器外,还有一些带数字的寄存器,r8-r15, 64位和32位有一些名字相似的寄存器,例如rsp, esp, 因为我们现在的大部分cpu都是64位的, 而为了兼容32位程序, 一个64位寄存器rsp的低32位就会被当作esp, 再往下兼容, 低32位的低16位还可以作为sp寄存器,sp是stack point(栈指针的缩写),esp是extend sp的缩写, rsp, 维基百科上说, 就是加了一个前缀来区分, 也可以认为是reextend.
### 基本操作指令
mov eax ebx , 第一个是操作指令, 第二个是目的操作数,第三个为操作数
- mov :  mov eax ebx, 把ebx中的值移动到eax中
- push/pop: 向栈顶压入,从栈中弹出一个数据
- inc/dec : 对应c里面的 ++a或--a
- add/sub: add esp,eax: esp = esp + eax 加减
- mul/div: 乘除
- and/or/not: 与,或,非
- xor: 异或
- lea: load effective address, 把一个内存地址赋值给目的操作数
lea eax, 0x401234, eax的值就变为了这个地址
- call: 调用函数
- leave一个函数结束的时候会执行leave,它等效于 mov esp ebp, pop ebp, 具体使用等下再讲
- ret: 返回到调用它的函数
其实这些指令并不难记, 因为都是对应的英文, 当初设计汇编语言的人, 也是经过仔细思考, 才用的这套注记符. 
### 寻址方式: 
1. 立即数寻址: 操作数包含在指令中, 例如mov eax,6h
2. 寄存器寻址: 操作数在寄存器中,例如 mov eax,ebx
3. 相对基址索引寻址: 通过基址寄存器加上一个偏移来寻址:
mov eax, [esp + 10h], 打括号的操作就是读取那个地址里的值,就像c语言里面的解指针.
## 栈
### 栈帧的产生与消失
栈是程序运行时非常重要的一个数据结构, 它采用了数据后进先出的内存管理原则, 每次函数调用, 都会在栈中产生一个新的栈帧, 而在上一级的栈帧, 也就是调用调用者的栈帧, 就会被暂时挂起, 被调用的函数, 在新的栈帧中执行对数据的操作, 当被调用的函数结束, 被调用者的栈帧就会消失掉, 调用者之前被挂起的栈帧恢复, 然后调用者又继续执行下一条指令.
### 栈操作
在之前我们提到过, 栈会向低地址的方向增长, 而esp是栈寄存器,指向栈顶, 事实上, 栈的增长与消减, 都是通过esp寄存器来实现的.
sub esp,14h: 扩展栈空间
add esp, 14h: 消减栈空间
push eax = mov eax,[esp] + sub esp,4
pop eax = mov [esp], eax + add esp,4
注意, 上面的是esp加了括号, 表示操作的是esp地址对应处的值
### 调用约定
一个32位程序调用函数的方法, 所有的参数,都是调用者用push指令保存在栈中的, 而被调用者通过 ebp加上一定的偏移来取得参数. 最后经过一些列操作之后, 使用eax寄存器返回值. 这种模式, 被每个32位程序所遵守, 也成为调用约定, 而32位程序和64位程序又遵守不同的调用约定, c语言源码还是一样的源码, 这个是64位的程序, 分析一下, 可以看到, 在调用者函数中, 直接把参数移到了寄存器中, 被调用的函数再对寄存器操作, 其实32位和64位主要的区别也就是传参, 做题的时候主要也就在意这个传参.

# 堆
## preface
堆和栈都是计算机中很重要的数据结构, 栈用来保存函数中的临时变量, 全局变量保存在bss段和data段, 然而保存在中几个地方的数据都有一个缺点, 就是这些数据在编译时就把空间分配好了, 后续如果需要更多的空间, 就没有办法再申请, 如果不知道要存储多大的数据, 而在一开始就分配很大的空间, 又容易导致资源的浪费, 而且栈中的数据的生命周期很短, 没有办法持续存在. 这个时候, 就要用到堆了.
## 如何使用
只有一部分语言例如c/c++, golang能够自己管理内存, 而一些其它的语言, 例如java,c#和python只能够靠自带的内存管理系统来操作系统, 这两种方法都各有利, 也不能说哪一个就是完美的.
c语言中使用malloc和free函数就可以直接申请和释放堆内存了
c艹中使用new和delete方法.
## 链表的实现
堆当中, 最简单的实现其实就是一个单向的链表,链表是一种常见的基础数据结构，结构体指针在这里得到了充分的利用。链表可以动态的进行存储分配，也就是说，链表是一个功能极为强大的数组，他可以在节点中定义多种数据类型，还可以根据需要随意增添，删除，插入节点。链表都有一个头指针，一般以head来表示，存放的是一个地址。链表中的节点分为两类，头结点和一般节点，头结点是没有数据域的。链表中每个节点都分为两部分，一个数据域，一个是指针域。现在我们以前来实现一个简单的链表:

```cpp
#include <iostream>

using namespace std;
// 堆中最底层的思想就是使用一个结构体,这个结构体中需要一块地方存放数据,另一块地方存储指向下一个结构体的指针
struct heap
{
    char ch;//存放数据
    heap *next; //指向下一个结构体
};

int main()
{
    heap head,mid,end; //创建几个结构体
    head.next = &mid; // 将head与mid链接起来
    head.next->next = &end; // 将mid与end链接起来
	//head->mid->end
    head.ch = '1';
    head.next->ch = '2'; //通过"->"来访问下一个结构体
    head.next->next->ch = '3';

    cout <<"head.next: "<<head.next<<'\n'
         <<"&mid: "<<&mid<<" mid.next: "<<mid.next<<'\n'
         <<"&end: "<<&end<<endl;

}
```
这样就生成了一个非常简单的链表.
## 堆的机制
我们现在知道了堆的一些基本性质, 现在来让我们看一下堆分配内存后的系统调用:
当我们使用malloc函数后, 系统会使用两种方式去给我们提供可用的空间/
- 第一种是操作系统提供的brk函数,或者glibc提供的sbrk函数: 初始时，堆的起始地址 start_brk 以及堆的当前末尾 brk 指向同一地址。当malloc选择使用brk来增加堆块的大小时, 就会把brk的地址向上怎讲实现堆块扩展: 调试, 断点打到getchar, vmmap查看sbrk前后的堆块, 可以发现都是连在一起的

- 第二种是mmap, malloc会使用mmap来创建独立的匿名映射段, 匿名映射段的主要目的是可以申请以0填充的内存, 并且这块内存只能被调用mmap的那个进程使用: 可以看到,mmap申请的堆块, 并没有和原来的heap段合并到一起,在unmmap后又消失了
  这就是两个堆函数操作后的效果.

  ## 演示:

  - sbrk:

  ```cpp
  /* sbrk and brk example */
  #include <stdio.h>
  #include <unistd.h>
  #include <sys/types.h>
  
  int main()
  {
          void *curr_brk, *tmp_brk = NULL;
  
          printf("sbrk 实例演示:\n");
  
          /* sbrk(0) gives current program break location */
          tmp_brk = curr_brk = sbrk(0);
          printf("调用brk函数前的brk指针: %p\n", curr_brk);
          getchar();
  
          /* brk(addr) increments/decrements program break location */
          brk(curr_brk+409600);
  
          curr_brk = sbrk(0);
          printf("调用brk函数增加堆后的brk指针:%p\n", curr_brk);
          getchar();
  
          brk(tmp_brk);
  
          curr_brk = sbrk(0);
          printf("减小brk指针后:%p\n", curr_brk);
          getchar();
  
          return 0;
  }
  ```
  - vmmap:

  ```cpp
  /* Private anonymous mapping example using mmap syscall */
  #include <stdio.h>
  #include <sys/mman.h>
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <fcntl.h>
  #include <unistd.h>
  #include <stdlib.h>
  
  void static inline errExit(const char* msg)
  {
          printf("%s failed. Exiting the process\n", msg);
          exit(-1);
  }
  
  int main()
  {
          int ret = -1;
          printf("mmap独立匿名映射段演示, 进程pid:%d\n", getpid());
          printf("mmap前\n");
          getchar();
          char* addr = NULL;
          addr =(char *) mmap(NULL, (size_t)132*1024, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
          if (addr == MAP_FAILED)
                  errExit("mmap");
          printf("mmap后\n");
          getchar();
  
          /* Unmap mapped region. */
          ret = munmap(addr, (size_t)132*1024);
          if(ret == -1)
                  errExit("munmap");
          printf("munmap后\n");
          getchar();
          return 0;
  }
  ```
